## July 24th diary entry

- With the help of mppf's suggestions, I had introduced the sizes per dimension as an extra argument in `polly_array_index()`. It has no use in the function per se, it is just present so that polly can extract the dimension sizes and put them into strides. With the appropriate changes made to both polly and chapel, we tried to generate GPU code and run it. It partially initialized the array. On analyzing memory checks with `cuda-memcheck` it showed some out of bound accesses. This was because the kernel definition, which is generated by PPCGCodegen, assumes the dimension sizes as block values which are used for creating appropriate index, which is wrong. So here a dilemma occurs,
* If strides are block values, indexing is correct but memory is wrongly allocated, because of misassumption of block values as dimension sizes
* If strides are dimension sizes, memory allocation is perfect, but index expression generated is wrong , because of misassumption of dimension sizes as block values.

This calls for a major change in `ShapeInfo` class. Initially, we try to add an extra member called `dimSizes` in it, which is initialized only when we use the stride approach. After making the appropriate changes, we test for successful GPU codegen by running and checking for memory leaks. If success, then we optimise this approach by discarding the block values as arguments, which will be calculated in the function from dimension sizes. This will reduce dependency on memory transfer which can be costly.
