## June 14th entry

### Solving the non-affine access issue using previous patch
- Instead of manually replacing the parameter by its value every time in the LLVM-IR, I had found a way out by using the earlier patch for collective invariant loads and GEP's. While analyzing the cause of non affine access error remark, the issue arose when `%55` was being checked if it was affine or not. Ideally, it should be, but it didn't.The cause of this was that while checking for invariant loads, `isHoistableLoads()` function had a wrong ILS given to it. After rectifying the change in the codebase and redoing the whole procedure. It surprisingly worked. `-polly-detect` gave no errors and the scop generated had delinearized accesses in it. What's more is that `containsMatrMult()` was returning True, meaning matmul was getting recognized by Polly. The perf measurements suggested same time (almost) for both the cases. But, on changing the iteration domains of the arrays from `1..1000` to `0..999`, everything worked fine and perf measurements suggested huge margin performance gain for polly optimized version rather than the original IR.

### Discussion on implementing a more concrete solution to enable matmul detection by Polly.
- The current success of matmul detection is dependent solely on the earlier patch which handles collective invariant loads and GEP's. The nature of this solution is actually simple pattern matching on the collection of instructions, which can't be generalized across IR's from different languages. So, there needs to be a concrete and more general solution to this problem. Siddharth, initially suggested developing a custom intrinsic for Chapel's array descriptor to convey it's data to Polly. One of the strengths of this approach is that by using an intrinsic, we can circumvent all the patterns of loads and GEP's which Polly doesn't understand currently. We also had some amount of discussion on why does the change in Iteration Domain help Polly to recognize the SCoP. The reason is that the accessed data is from the data field of `defaultRectangular` module. this field always contains the first element of the array according to the iteration domain, whereas the shiftedData field is always 0-indexed. To disable the use of shiftedData, `-searlyShiftData=false` was used while compiling Chapel Code to LLVM-IR. The result was that, Polly was not able to detect Chapel's access functions which were different in this case.The access functions used here were of the type:
```
((8 * (({0,+,1}<nuw><nsw><%49> * %57) + {0,+,1}<nuw><nsw><%50> + %55)) + (-8 * %60))
``` 
Here the parameters used along with the induction variables are block (size of a row in 2D array), origin and factoredOffset(address of the first element), respectively. Further discussion was made taking into account 3D arrays and it's offsets used for accessing array memory.It further depends on whether the dimensions are known before as constants. If it is known, then we can just use `divide and un-offset` rule to obtain the accesses in each dimension. So, array shape needs to be conveyed to Polly to achieve this. So instead of using a custom 'array access intrinsic', we can just convey Chapel's array shapes to Polly, who will take care of Delinearization.

Michael Kruse and Michael Ferguson has some further discussions regarding intrinsics. It turns out that Michael Kruse had previously developed one for dynamically sized arrays. This can be employed for Chapel's situation and perhaps need to convince the community to accept this.
